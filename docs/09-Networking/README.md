# Networking

[메인으로 돌아가기](../../README.md)

## Pod Networking

- 클러스터 외부에서 뿐만 아니라 클러스터 내에서 내부적으로도 파드에서 실행되는 서비스에 어떻게 접근할 수 있을까?
- 쿠버네티스에서는 이러한 솔루션을 내장하여 지원하지 않는다. 쿠버네티스는 이러한 부분을 해결하는 네트워킹 솔루션을 구현할 수 있기를 기대한다
- 쿠버네티스는 모든 pod이 고유한 IP주소를 얻고, 모든 파드가 해당 IP 주소를 사용하여 동일한 노드 내의 다른 모든 파드에 연결할 수 있어야 한다고 예상한다. 이러한 요구사항을 충족시켜야한다.
- IP 주소나 IP 주소의 범위나 서브넷은 상관이 없다. IP 주소를 자동으로 할당하는 솔루션을 구현하고 노드의 파드와 다른 노드의 파드 간에 연결을 설정할 수 있다면 된다.
  1. 컨테이너가 생성되면, 쿠버네티스는 상호 간 통신을 위해 네트워크 네임스페이스를 생성하고, 이 네임스페이스를 네트워크에 연결한다. 여기서 생성한 네트워크는 브릿지 네트워크이다. 즉, 각 노드에 브릿지
     네트워크를 생성한다.
  2. 각 브릿지 네트워크, 브릿지 인터페이스에 IP 주소를 할당한다.
- 이후 단계는 새 컨테이너가 생성될 때마다 각 컨테이너에 대해 수행한다.
  1. veth(가상 이더넷 네트워크)를 생성하고, veth를 연결한다. IP 주소를 할당하고, 인터페이스 시작하는 하나의 스크립트를 생성하여 각 컨테이너에 적용한다.
- 이제 각 컨테이너는 상호 간 통신이 가능하다. 그리고 다른 노드와의 통신을 위해서는 아래의 과정이 필요하다.
  1. 라우팅 테이블을 이용해 모든 호스트에 대해 route를 구성한다.
- 수동으로 스크립트를 매번 작성하고, 실행시키는 수고들 덜기 위해 도입된 것이 CNI이다. CNI 표준에 맞춰 정의하면 실제로는 CNI를 통해 위의 과정이 수행된다.
- kubelet은 노드에서 컨테이너가 생성될 때마다 net-script.sh 스크립트를 실행하여 네트워크 구성을 자동화한다.
  ```bash
  ./net-script.sh add <container> <namespace>
  ```

## CNI in Kubernetes

- CNI 플러그인은 클러스터의 각 노드에 있는 kubelet.service에서 구성된다.
- 아래 명령어를 통해 설정된 네트워크 플러그인을 확인할 수 있다. `—cni-conf-dir`, `—cni-bin-dir`, `—network-plugin` 옵션을 살펴보면 된다.
  ```bash
  ps -aux | grep kubelet
  ```

## Service Networking

- 서비스는 어떻게 IP를 얻으며 어떻게 클러스터 내의 모든 노드에서 IP 주소를 사용할 수 있는 것일까? 또한 각 노드의 포트를 통해 외부 사용자가 서비스를 이용할 수 있는 방법은 무엇일까?
- kube-apiserver를 통해 새로운 파드가 생성되고, 그 파드가 노드에 생성되는 등 kubelet은 클러스터 내의 모든 변화를 감시하고 있다. 이후 CNI 플러그인을 호출하여 해당 파드에 대한 네트워킹을
  구성한다.
- 마찬가지로 각 노드에서는 kube-proxy를 실행한다. 새 서비스가 생성될 때마다 실행된다.
- 서비스는 클러스터 차원의 개념이며, 클러스터의 모든 노드에 존재한다.
- 실제로 서비스의 IP를 수신하는 서버나 서비스는 없다. 파드에는 컨테이너가 있고, 컨테이너에는 인터페이스가 있는 네임스페이스가 있으며, IP는 서비스가 있는 인터페이스에 할당되어 있다.
- 서비스에 대한 프로세스, 네임스페이스, 인터페이스는 없다. 이것은 가상의 오브젝트일 뿐이다. 그렇다면 더더욱 궁금한 것은 어떻게 IP 주소를 얻고 서비스를 통해 파드의 애플리케이션에 접근할 수 있는걸까?
- 서비스 오브젝트가 생성되면 미리 정의된 범위에서 IP 주소가 할당된다. 각 노드에서 실행 중인 kube-proxy는 해당 IP 주소를 가져오고, 클러스터의 각 노드에 forwarding rules(이 IP로
  들어오는 트래픽을 특정 IP로 보내는 규칙)를 만든다.
- kube-proxy는 userspace, ipvs, iptables라는 다양한 방법을 지원하며 기본 옵션은 iptables이다. 이는 다음과 같이 설정할 수 있다:
  ```bash
  kube-proxy —proxy-mode [ userspace | iptables | ipvs ]
  ```
- 생성한 파드를 조회해보면 IP 주소를 확인할 수 있다. 그리고 생성한 서비스를 조회하면 기본적으로 ClusterIP 타입으로 지정되어 있으며, 이에 해당하는 IP 주소 또한 확인할 수 있다. 이러한 주소는
  kube-api-server의 `—service-cluster-ip-range` 옵션으로 정해진다.
  ```bash
  kube-api-server —service-cluster-ip-range ipNet
  ```
- 아래 명령어를 통해 kube-proxy에 의해 생성된 규칙을 확인할 수 있다.
  ```bash
  iptables -L -t nat | grep db-service
  ```
- 아래의 명령어를 통해 로그를 확인할 수 있다. 로그 확인시 어떤 옵션으로 규칙이 생성되었으며, 어떤 서비스가 생성되었고, 어떤 IP에 할당되었는지도 확인이 가능하다.
  ```bash
  cat /var/log/kube-proxy.log
  ```

## DNS in Kubernetes

- 쿠버네티스는 기본적으로 내장 DNS 서버를 배포한다.
- 서비스가 생성되면 쿠버네티스 DNS 서버는 서비스를 위한 레코드를 생성하고, 서비스 이름과 IP 주소를 매핑한다. 이로 인해 클러스터 내에서 어느 파드에서든 서비스 이름을 통해 접근할 수 있다.
- 서비스의 네임스페이스가 다르면 servicename.namespace으로 도메인이 생성된다.
- 파드는 IP 주소의 온점 대신 대시로 변환되어 pod-ip-with-dash.namespace.svc.cluster.local과 같이 도메인이 생성된다.

## CoreDNS in Kubernetes

- 쿠버네티스 v1.12 이후 권장되는 DNS 서버는 CoreDNS이다.
- 아래 명령어를 통해 CoreDNS의 구성을 확인할 수 있다.
  ```bash
  cat /etc/coredns/Corefile
  ```
- 해당 구성 파일은 파드에 컨피그맵으로 전달된다. 따라서 옵션 값을 변경하려면 컨피그맵을 수정하면 된다.
- CoreDNS 파드도 다른 파드의 요청을 처리하기 위해 kube-system 네임스페이스에 kube-dns라는 서비스를 생성한다.
- 각 파드는 처음 생성될 때 /etc/resolv.conf 파일에 kube-dns의 서비스 IP 주소가 네임서버로 등록ㅎ되어 있다.
- 이러한 사전 작업은 전부 kubelet이 담당한다.
- 그러면 web-service라는 이름만 가지고 FQDN을 어떻게 찾는 것일까?
- 아래 세 개의 도메인을 search로 추가해두었기 때문에 서비스의 경우 서비스 이름만으로도 FQDN을 만들 수 있다.
  - default.svc.cluster.local
  - svc.cluster.local
  - cluster.local
